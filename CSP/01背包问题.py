def bag01(n, w, c, v):  # 定义01背包函数，参数分别是物品数量(n)、重量列表(w)、背包容量(c)、价值列表(v)
    f = [[0]*(c+1) for _ in range(n+1)]  # 创建二维DP表，行数为n+1（包括0个物品的情况），列数为c+1（容量从0到c），初始化全为0
    for i in range(1, n+1):  # 外层循环，从1到n，依次考虑第i个物品（索引i-1）
        for j in range(1, c+1):  # 内层循环，从1到c，遍历所有可能的背包容量j
            if j < w[i-1]:  # 如果当前容量j小于第i-1个物品的重量w[i-1]，放不下来
                f[i][j] = f[i-1][j]  # 不选第i-1个物品，继承前i-1个物品在容量j下的最大价值
            else:  # 如果当前容量j大于等于第i-1个物品的重量，可以考虑选或不选
                f[i][j] = max(f[i-1][j], f[i-1][j-w[i-1]] + v[i-1])  # 取“不选”和“选”两种情况的最大值：
                # - 不选：f[i-1][j]（前i-1个物品在容量j的最大价值）
                # - 选：f[i-1][j-w[i-1]]（剩余容量下的最大价值）+ v[i-1]（当前物品价值）
    return f[n][c]  # 返回前n个物品在容量c下的最大价值，即最终答案

num = 4  # 定义物品数量为4
weight = [2, 3, 4, 5]  # 定义物品重量列表，分别对应4个物品的重量
value = [3, 4, 5, 6]  # 定义物品价值列表，分别对应4个物品的价值
capacity = 10  # 定义背包容量为10
value_max = bag01(num, weight, capacity, value)  # 调用bag01函数，传入参数，计算最大价值并赋值给value_max
print(value_max)  # 输出最大价值




# for i range(1,n+1):
#     for j in range(1,c+1):
#         if w[i-1]<j:
#             f[i][j]=f[i-1][j]
#         else:
#             f[i][j]=max(f[i-1][j],f[i-1][j-w[i-1]]+v[i-1])


